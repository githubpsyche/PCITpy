---

title: Additional Helper Functions


keywords: fastai
sidebar: home_sidebar

summary: "Miscellaneous functions reused across the toolbox to carry out simple numerical operations"
description: "Miscellaneous functions reused across the toolbox to carry out simple numerical operations"
nb_path: "00_Miscellaneous_Helper_Functions.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 00_Miscellaneous_Helper_Functions.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Note:</strong> A few helper functions included in the MATLAB version of the PCIT toolbox are not present here. When it comes to numerical helper functions <code>logsumexp.m</code> and <code>round_to.m</code>, this is because a Python version of the function is already included in a required scientific programming library such as <code>scipy</code> or <code>numpy</code>. When it comes to visualization helper functions <code>savesamesize.m</code> and <code>jbfill.m</code>, it's because equivalent Python functions are either unnecessary or not applicable in the context of <code>matplotlib</code>'s library. In either case, equivalent functionality is achieved without implementation of an additional toolbox function.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="likratiotest" class="doc_header"><code>likratiotest</code><a href="https://github.com/githubpsyche/pcitpy/tree/master/pcitpy/helpers.py#L9" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>likratiotest</code>(<strong><code>l1</code></strong>, <strong><code>l0</code></strong>, <strong><code>k1</code></strong>, <strong><code>k0</code></strong>)</p>
</blockquote>
<p>Performs the likelihood ratio test for nested models.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li>L1: log-likelihood for alternative model</li>
<li>L0: log-likelihood for the null model</li>
<li>K1: number of parameters for alternative model</li>
<li>K0: number of parameters for null model (K1 &gt; K0)</li>
</ul>
<p><strong>Returns</strong>:</p>
<ul>
<li>D: deviate score: -2*log(L1-L0)</li>
<li>p: p-value from chi-squared test with degrees of freedom = K1-K0</li>
</ul>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This function implements the $\beta_1$ likelihood-ratio test described in Section 4.10 of the <a href="https://github.com/PrincetonUniversity/p-cit-toolbox">P-CIT Toolbox Manual</a>.</p>
<p>If we want to build confidence that this function is an exact reproduction of the MATLAB implementation, we can ask whether our version returns <code>(-20, 1)</code> for the arguments <code>(l1=10.0, l0=20.0, k1=8.0, k0=5.0)</code> as the MATLAB version does:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">likratiotest</span><span class="p">(</span><span class="n">l1</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">l0</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span> <span class="n">k1</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span> <span class="n">k0</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><code>(-20.0, 1.0)</code></p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="truncated_normal" class="doc_header"><code>truncated_normal</code><a href="https://github.com/githubpsyche/pcitpy/tree/master/pcitpy/helpers.py#L34" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>truncated_normal</code>(<strong><code>a</code></strong>, <strong><code>b</code></strong>, <strong><code>mu</code></strong>, <strong><code>sigma</code></strong>, <strong><code>n</code></strong>)</p>
</blockquote>
<p>Generates N samples from a truncated normal distribution with mean=mu,
sigma=sigma and with bounds A and B.</p>
<p>We use this function in our toolbox to add noise from a truncated Gaussian
distribution.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li>A: lower bound</li>
<li>B: upper bound</li>
<li>mu: mean</li>
<li>sigma: sigma, standard deviation</li>
<li>N: number of samples</li>
</ul>
<p><strong>Returns</strong> array of length N containing mean + truncated Gaussian noise with
mean=mu, sigma=sigma, between bounds A and B</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As an example, we can generate and visualize the result of applying the function to some arbitrary paremeters:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># generate a sample</span>
<span class="n">sample</span> <span class="o">=</span> <span class="n">truncated_normal</span><span class="p">(</span><span class="n">a</span><span class="o">=.</span><span class="mi">7</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mf">1.3</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mf">10000.0</span><span class="p">)</span>

<span class="c1"># visualize its distribution</span>
<span class="n">n_bins</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">n_bins</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;truncated_normal(a=.7, b=1.3, mu=1.0, sigma=.1, n=10000.0)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;figures/truncated_normal_example.svg&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">sample</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="/pcitpy/figures/truncated_normal_example.svg" alt=""></p>

<pre><code>array([0.88296168, 1.22801193, 0.8565991 , ..., 0.87280798, 1.09364587,
       0.96110738])</code></pre>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="scale_data" class="doc_header"><code>scale_data</code><a href="https://github.com/githubpsyche/pcitpy/tree/master/pcitpy/helpers.py#L70" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>scale_data</code>(<strong><code>data</code></strong>, <strong><code>lower</code></strong>=<em><code>-1.0</code></em>, <strong><code>upper</code></strong>=<em><code>1.0</code></em>)</p>
</blockquote>
<p>Scale the elements of all the column vectors in Data within the range
of [Lower Upper]; default range is [-1 1]</p>
<p>We use this function in our toolbox to scale the predictor variable
between 0 and 1.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li>Data: data, numeric vector</li>
<li>Lower: lower range, numeric</li>
<li>Upper: upper range, numeric</li>
</ul>
<p><strong>Returns</strong>:</p>
<ul>
<li>scaled: 1xN array containing scaled data</li>
</ul>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As an example we can execute the function with a few arbitrary parameters:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">scale_data</span><span class="p">([</span><span class="mf">8.3256</span><span class="p">,</span> <span class="mf">1000.0</span><span class="p">,</span> <span class="mf">23.0</span><span class="p">,</span> <span class="mf">564.0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As specified, it returns the vector scaled between 0 and 1.</p>
<p><code>array([[0.        , 1.        , 0.0147976 , 0.56033956]])</code></p>
<p>Notably, the output is 2-dimensional rather than a vector; this enforces consistency in the shape of the function's output regardless of the shape of the input. It also helps ensure compatibility with other code translated from the MATLAB implementation of the toolbox.</p>

</div>
</div>
</div>
</div>
 

